const moment = require("moment")const formatCurrency = (amount, forPDF = false) => {  if (forPDF) {    return `â‚¹${(amount || 0).toLocaleString("en-IN", {      minimumFractionDigits: 2,      maximumFractionDigits: 2,    })}`  }  return new Intl.NumberFormat("en-IN", {    style: "currency",    currency: "INR",    minimumFractionDigits: 2,  }).format(amount || 0)}const getDateRange = (filter) => {  const endDate = new Date()  endDate.setHours(23, 59, 59, 999)  const startDate = new Date()  switch (filter) {    case "daily":      startDate.setDate(startDate.getDate() - 30)      startDate.setHours(0, 0, 0, 0)      break    case "weekly":      startDate.setDate(startDate.getDate() - 84) // 12 weeks      startDate.setHours(0, 0, 0, 0)      break    case "monthly":      startDate.setMonth(startDate.getMonth() - 12)      startDate.setHours(0, 0, 0, 0)      break    case "yearly":      startDate.setFullYear(startDate.getFullYear() - 5)      startDate.setHours(0, 0, 0, 0)      break    default:      startDate.setDate(startDate.getDate() - 30)      startDate.setHours(0, 0, 0, 0)  }  return { startDate, endDate }}const groupDataByTimePeriod = (data, period) => {  const groupedData = {}  data.forEach((item) => {    let key    const date = new Date(item.orderDate || item.createdAt)    switch (period) {      case "daily":        key = moment(date).format("YYYY-MM-DD")        break      case "weekly":        const weekStart = moment(date).startOf("isoWeek")        key = `Week of ${weekStart.format("MMM DD, YYYY")}`        break      case "monthly":        key = moment(date).format("MMM YYYY")        break      case "yearly":        key = moment(date).format("YYYY")        break      default:        key = moment(date).format("YYYY-MM-DD")    }    if (!groupedData[key]) {      groupedData[key] = {        count: 0,        revenue: 0,        discount: 0,        couponDiscount: 0,        date: date,      }    }    groupedData[key].count += 1    groupedData[key].revenue += item.finalAmount || 0    groupedData[key].discount += item.discount || 0    if (item.coupon && item.coupon.discountAmount) {      groupedData[key].couponDiscount += item.coupon.discountAmount    }  })  return Object.entries(groupedData)    .map(([key, value]) => ({      period: key,      ...value,    }))    .sort((a, b) => a.date - b.date)}const calculatePercentage = (part, total) => {  if (!total || total === 0) return 0  return (part / total) * 100}const generateDateRange = (startDate, endDate) => {  const dates = []  const currentDate = new Date(startDate)  while (currentDate <= endDate) {    dates.push(new Date(currentDate))    currentDate.setDate(currentDate.getDate() + 1)  }  return dates}const formatDate = (date, format = "MMM DD, YYYY") => {  return moment(date).format(format)}const calculateGrowth = (current, previous) => {  if (!previous || previous === 0) {    return current > 0 ? 100 : 0  }  return ((current - previous) / previous) * 100}const roundToDecimals = (num, decimals = 2) => {  return Math.round((num + Number.EPSILON) * Math.pow(10, decimals)) / Math.pow(10, decimals)}const getPeriodLabel = (period) => {  const labels = {    daily: "Daily",    weekly: "Weekly",    monthly: "Monthly",    yearly: "Yearly",    custom: "Custom Range",  }  return labels[period] || "Unknown"}const isValidDateRange = (startDate, endDate) => {  if (!startDate || !endDate) return false  return startDate <= endDate}module.exports = {  formatCurrency,  getDateRange,  groupDataByTimePeriod,  calculatePercentage,  generateDateRange,  formatDate,  calculateGrowth,  roundToDecimals,  getPeriodLabel,  isValidDateRange,}